package com.design.pattern.proxy;
/**
 * 
 * @author dell
 * 代理模式：
 * 	重点：代理类和被代理类实现了同一个接口。
 * 	什么是代理：游戏中的代练人员：本来是自己要打怪升级的，但是由于空闲时间不够，升级太慢，所以找一个人替代自己去打怪升级。
 * 	定义：为其他对象提供一种代理以控制对这个对象的访问。
 * 	组成：
 * 	   1.Subject抽象主题角色：就像是游戏人物，能够实现一些打怪，升级的功能；
 * 	   2.RealSubject:具体主题角色：被代理角色，业务逻辑的具体执行者(自己)；
 * 	   3.Proxy:代理主题角色：代理角色，负责操作具体角色(代练)，把所有主题类的方法限制委托给RealSubject实现，并且在具体主题完成前后做预处理和善后工作。
 * 	扩展：最简单的，一个代理类代理一个具体类，可是，一个代理类也可以代理多个被代理类，但是一个接口只能有一个代理类，因此需要在代理的构造中传入被代理对象。
 * 	优点：
 * 	   1.职责清晰：RealSubject只实现实际的业务逻辑，不关心其他非本职事务。通过后期的代理完成一件事务。
 * 	   2.扩展性高：RealSubject被抽象的主题约束，因此，无论realSubject如何改变，代理类都可以在不变的情况下使用。
 * 	   3.智能化：通过动态代理。
 * 	种类：
 * 		1.普通代理：不能访问真实角色，只能访问代理角色。
 * 		2.强制代理：只能访问由真实角色指定的代理角色
 */
public class Client {

}
